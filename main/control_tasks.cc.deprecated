#include "task_manager.h"
#include "lvgl_ui.h"
#include "config.h"
#include "led_controller.h"
#include "system_monitor.h"
#include <lvgl.h>
#include <esp_log.h>
#include <esp_websocket_client.h>
#include <string.h>

static const char* TAG = "ctrl_tasks";

// WebSocket客户端句柄
static esp_websocket_client_handle_t g_ws_client = nullptr;

// ============================================================================
// Core 0 控制任务
// ============================================================================

// WebSocket事件处理函数
static void websocket_event_handler(void* handler_args, esp_event_base_t base,
                                     int32_t event_id, void* event_data) {
    esp_websocket_event_data_t* data = (esp_websocket_event_data_t*)event_data;

    switch (event_id) {
        case WEBSOCKET_EVENT_CONNECTED: {
            ESP_LOGI(TAG, "WebSocket connected to server");
            // 发送连接事件到状态机
            state_event_msg_t event = { .type = STATE_EVENT_WS_CONNECTED };
            send_state_event(event);
            break;
        }

        case WEBSOCKET_EVENT_DISCONNECTED: {
            ESP_LOGW(TAG, "WebSocket disconnected from server");
            state_event_msg_t disc_event = { .type = STATE_EVENT_WS_DISCONNECTED };
            send_state_event(disc_event);
            break;
        }

        case WEBSOCKET_EVENT_DATA: {
            if (data->op_code == 0x02) {  // Binary frame
                ESP_LOGI(TAG, "Received WebSocket binary data: %d bytes", data->data_len);

                // 接收到的是Opus包，发送到解码队列
                if (data->data_len > 0 && data->data_len < 1024) {
                    opus_packet_msg_t* msg = alloc_opus_msg(data->data_len);
                    if (msg) {
                        memcpy(msg->data, data->data_ptr, data->data_len);
                        if (xQueueSend(g_ws_rx_queue, &msg, 0) != pdTRUE) {
                            ESP_LOGW(TAG, "RX queue full, dropping packet");
                            free_opus_msg(msg);
                        }
                    }
                }
            }
            break;
        }

        case WEBSOCKET_EVENT_ERROR:
            ESP_LOGE(TAG, "WebSocket error");
            break;

        default:
            break;
    }
}

/**
 * @brief WebSocket任务 - 网络通信
 *
 * 优先级: 8
 * 核心: Core 0
 * 栈: 8KB
 */
void websocket_task(void* arg) {
    ESP_LOGI(TAG, "WebSocket task started on core %d", xPortGetCoreID());

    // 等待WiFi连接
    ESP_LOGI(TAG, "Waiting for WiFi connection...");
    xEventGroupWaitBits(g_app_event_group, EVENT_WIFI_CONNECTED,
                       pdFALSE, pdTRUE, portMAX_DELAY);
    ESP_LOGI(TAG, "WiFi connected, starting WebSocket client");

    // 配置WebSocket客户端
    esp_websocket_client_config_t ws_cfg = {};
    ws_cfg.uri = ECHOEAR_WS_URL;
    ws_cfg.task_stack = 0;  // 不创建自己的任务（在此任务中运行）
    ws_cfg.buffer_size = 4096;
    ws_cfg.reconnect_timeout_ms = 5000;
    ws_cfg.network_timeout_ms = 10000;
    ws_cfg.ping_interval_sec = 10;

    // 初始化WebSocket客户端
    g_ws_client = esp_websocket_client_init(&ws_cfg);
    if (!g_ws_client) {
        ESP_LOGE(TAG, "Failed to initialize WebSocket client");
        vTaskDelete(NULL);
        return;
    }

    // 注册事件处理函数
    esp_websocket_register_events(g_ws_client, WEBSOCKET_EVENT_ANY,
                                  websocket_event_handler, nullptr);

    // 连接WebSocket服务器
    ESP_LOGI(TAG, "Connecting to %s", ECHOEAR_WS_URL);
    esp_err_t ret = esp_websocket_client_start(g_ws_client);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start WebSocket client: %d", ret);
        esp_websocket_client_destroy(g_ws_client);
        vTaskDelete(NULL);
        return;
    }

    ESP_LOGI(TAG, "WebSocket client started");

    uint32_t tx_count = 0;
    uint32_t tx_bytes = 0;

    while (1) {
        opus_packet_msg_t* msg = nullptr;

        // 从发送队列获取Opus包（100ms超时）
        if (xQueueReceive(g_ws_tx_queue, &msg, pdMS_TO_TICKS(100)) == pdTRUE) {
            if (msg && msg->data && msg->len > 0) {
                // 检查WebSocket是否已连接
                if (esp_websocket_client_is_connected(g_ws_client)) {
                    // 发送二进制数据
                    int sent = esp_websocket_client_send_bin(g_ws_client,
                                                             (const char*)msg->data,
                                                             msg->len,
                                                             pdMS_TO_TICKS(1000));
                    if (sent > 0) {
                        tx_count++;
                        tx_bytes += sent;

                        // 每10个包打印一次统计
                        if (tx_count % 10 == 0) {
                            ESP_LOGI(TAG, "WebSocket TX: packets=%lu, bytes=%lu",
                                     tx_count, tx_bytes);
                        }
                    } else {
                        ESP_LOGW(TAG, "Failed to send WebSocket data");
                    }
                } else {
                    ESP_LOGW(TAG, "WebSocket not connected, dropping packet");
                }
            }

            free_opus_msg(msg);
        }
    }

    // 清理（通常不会到达这里）
    esp_websocket_client_stop(g_ws_client);
    esp_websocket_client_destroy(g_ws_client);
    vTaskDelete(NULL);
}

/**
 * @brief 状态机任务 - 应用状态管理
 *
 * 优先级: 6
 * 核心: Core 0
 * 栈: 8KB
 */
void state_machine_task(void* arg) {
    ESP_LOGI(TAG, "State machine task started on core %d", xPortGetCoreID());

    // TODO: 实现状态机主循环
    // - 处理状态事件
    // - 状态转换
    // - 业务逻辑

    while (1) {
        state_event_msg_t event;

        // 等待状态事件
        if (xQueueReceive(g_state_event_queue, &event, pdMS_TO_TICKS(100)) == pdTRUE) {
            // 处理事件
            switch (event.type) {
                case STATE_EVENT_WIFI_CONNECTED:
                    ESP_LOGI(TAG, "Event: WiFi connected");
                    xEventGroupSetBits(g_app_event_group, EVENT_WIFI_CONNECTED);
                    LedController::instance().set_system_state(LedController::SystemState::IDLE);
                    break;

                case STATE_EVENT_WIFI_DISCONNECTED:
                    ESP_LOGI(TAG, "Event: WiFi disconnected");
                    xEventGroupClearBits(g_app_event_group, EVENT_WIFI_CONNECTED);
                    LedController::instance().set_system_state(LedController::SystemState::NO_WIFI);
                    break;

                case STATE_EVENT_WS_CONNECTED:
                    ESP_LOGI(TAG, "Event: WebSocket connected");
                    xEventGroupSetBits(g_app_event_group, EVENT_WS_CONNECTED);
                    LedController::instance().set_system_state(LedController::SystemState::LISTENING);
                    break;

                case STATE_EVENT_WS_DISCONNECTED:
                    ESP_LOGI(TAG, "Event: WebSocket disconnected");
                    xEventGroupClearBits(g_app_event_group, EVENT_WS_CONNECTED);
                    LedController::instance().set_system_state(LedController::SystemState::NO_NETWORK);
                    break;

                case STATE_EVENT_WAKE_DETECTED:
                    ESP_LOGI(TAG, "Event: Wake detected - %s", event.data.wake.wake_word);
                    xEventGroupSetBits(g_app_event_group, EVENT_WAKE_DETECTED);
                    xEventGroupSetBits(g_app_event_group, EVENT_RECORDING_START);
                    LedController::instance().set_system_state(LedController::SystemState::WAKE_DETECTED);
                    LedController::instance().blink_once(2, 150);  // 快速闪烁2次表示检测到唤醒词
                    break;

                case STATE_EVENT_VAD_START:
                    ESP_LOGI(TAG, "Event: VAD start");
                    xEventGroupSetBits(g_app_event_group, EVENT_VAD_START);
                    LedController::instance().set_system_state(LedController::SystemState::RECORDING);
                    break;

                case STATE_EVENT_VAD_END:
                    ESP_LOGI(TAG, "Event: VAD end");
                    xEventGroupClearBits(g_app_event_group, EVENT_VAD_START);
                    xEventGroupSetBits(g_app_event_group, EVENT_RECORDING_END);
                    LedController::instance().set_system_state(LedController::SystemState::THINKING);
                    break;

                case STATE_EVENT_TTS_START:
                    ESP_LOGI(TAG, "Event: TTS start");
                    xEventGroupSetBits(g_app_event_group, EVENT_TTS_START);
                    LedController::instance().set_system_state(LedController::SystemState::SPEAKING);
                    break;

                case STATE_EVENT_TTS_END:
                    ESP_LOGI(TAG, "Event: TTS end");
                    xEventGroupClearBits(g_app_event_group, EVENT_TTS_START);
                    LedController::instance().set_system_state(LedController::SystemState::LISTENING);
                    break;

                case STATE_EVENT_TOUCH_PRESSED:
                    ESP_LOGI(TAG, "Event: Touch pressed");
                    xEventGroupSetBits(g_app_event_group, EVENT_TOUCH_PRESSED);
                    // 触摸也可以触发录音
                    xEventGroupSetBits(g_app_event_group, EVENT_RECORDING_START);
                    LedController::instance().set_system_state(LedController::SystemState::RECORDING);
                    break;

                case STATE_EVENT_ERROR:
                    ESP_LOGE(TAG, "Event: Error - %s", event.data.error.message);
                    LedController::instance().set_system_state(LedController::SystemState::ERROR);
                    break;

                default:
                    ESP_LOGW(TAG, "Unknown event type: %d", event.type);
                    break;
            }
        }

        // TODO: 检查状态转换条件
    }

    vTaskDelete(NULL);
}

/**
 * @brief UI更新任务 - LVGL界面更新
 *
 * 优先级: 3
 * 核心: Core 0
 * 栈: 8KB
 */
void ui_update_task(void* arg) {
    ESP_LOGI(TAG, "UI update task started on core %d", xPortGetCoreID());

    while (1) {
        ui_cmd_msg_t cmd;

        // 处理UI命令（非阻塞，100ms超时）
        if (xQueueReceive(g_ui_cmd_queue, &cmd, pdMS_TO_TICKS(100)) == pdTRUE) {
            // 所有LVGL操作在此任务中执行，保证线程安全
            switch (cmd.type) {
                case UI_CMD_SET_STATE:
                    lvgl_ui_set_state((ui_state_t)cmd.data.set_state.state);
                    break;

                case UI_CMD_SET_STATUS:
                    lvgl_ui_set_status(cmd.data.set_status.text);
                    break;

                case UI_CMD_SET_EXPRESSION:
                    lvgl_ui_set_expression((ui_expression_t)cmd.data.set_expression.expression);
                    break;

                case UI_CMD_SET_PUPIL:
                    lvgl_ui_set_pupil_offset(
                        cmd.data.set_pupil.x_offset,
                        cmd.data.set_pupil.y_offset
                    );
                    break;

                case UI_CMD_SHOW_TOAST:
                    // TODO: 实现toast显示
                    ESP_LOGI(TAG, "Toast: %s", cmd.data.show_toast.message);
                    break;

                default:
                    ESP_LOGW(TAG, "Unknown UI command: %d", cmd.type);
                    break;
            }
        }

        // LVGL定时任务
        lv_timer_handler();
    }

    vTaskDelete(NULL);
}

/**
 * @brief LED控制任务 - LED动画
 *
 * 优先级: 2
 * 核心: Core 0
 * 栈: 4KB
 */
void led_control_task(void* arg) {
    ESP_LOGI(TAG, "LED control task started on core %d", xPortGetCoreID());

    // TODO: LED动画控制
    // - 呼吸灯效果
    // - 状态指示

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    vTaskDelete(NULL);
}

/**
 * @brief 心跳任务 - 系统监控
 *
 * 优先级: 1
 * 核心: Core 0
 * 栈: 4KB
 */
void heartbeat_task(void* arg) {
    ESP_LOGI(TAG, "Heartbeat task started on core %d", xPortGetCoreID());

    uint32_t count = 0;

    while (1) {
        count++;

        // 每10秒打印一次系统状态
        if (count % 10 == 0) {
            ESP_LOGI(TAG, "=== System Heartbeat ===");

            // 打印事件组状态
            EventBits_t bits = xEventGroupGetBits(g_app_event_group);
            ESP_LOGI(TAG, "Events: WiFi=%d WS=%d Wake=%d VAD=%d TTS=%d Recording=%d",
                     (bits & EVENT_WIFI_CONNECTED) ? 1 : 0,
                     (bits & EVENT_WS_CONNECTED) ? 1 : 0,
                     (bits & EVENT_WAKE_DETECTED) ? 1 : 0,
                     (bits & EVENT_VAD_START) ? 1 : 0,
                     (bits & EVENT_TTS_START) ? 1 : 0,
                     (bits & EVENT_RECORDING_START) ? 1 : 0);

            // 打印内存使用
            ESP_LOGI(TAG, "Free heap: %lu bytes, PSRAM: %lu bytes",
                     esp_get_free_heap_size(),
                     heap_caps_get_free_size(MALLOC_CAP_SPIRAM));

            // 打印任务统计
            TaskManager::instance().print_task_stats();
        }

        // 每20秒打印完整系统报告
        if (count % 20 == 0) {
            SystemMonitor::instance().print_system_report();
        }

        // 每30秒检查栈使用
        if (count % 30 == 0) {
            TaskManager::instance().monitor_stack_usage();
        }

        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    vTaskDelete(NULL);
}
