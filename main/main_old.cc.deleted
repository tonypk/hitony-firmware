#include "config.h"
#include "ws_client.h"
#include "audio_i2s.h"
#include "wake_word.h"
#include "dns_server.h"
#include "lvgl_ui.h"
#include "opus_decoder.h"

#include <esp_log.h>
#include <nvs_flash.h>
#include <esp_event.h>
#include <esp_wifi.h>
#include <esp_netif.h>
#include <esp_http_server.h>
#include <esp_mac.h>
#include <cstring>
#include <cJSON.h>
#include <math.h>
#include <vector>
#include <mutex>
#include <freertos/FreeRTOS.h>
#include <freertos/event_groups.h>

static const char* TAG = "echoear";

// Audio buffer for smooth playback
static std::vector<uint8_t> audio_buffer;
static std::mutex audio_buffer_mutex;
static bool tts_active = false;
static bool tts_finished = false;
static size_t audio_buffer_read_pos = 0;
static constexpr size_t PREBUFFER_SIZE = 16000;  // ~500ms @ 16kHz mono PCM16

static WsClient ws;
static AudioI2S audio;
static WakeWord wake;
static OpusDecoder opus;

static bool wake_ready = false;

static EventGroupHandle_t wifi_event_group;
static const int WIFI_CONNECTED_BIT = BIT0;
static const int STREAMING_ACTIVE_BIT = BIT1;
static const int WS_CONNECTED_BIT = BIT2;
static httpd_handle_t http_server = nullptr;

static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        xEventGroupClearBits(wifi_event_group, WIFI_CONNECTED_BIT);
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        xEventGroupSetBits(wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

static bool nvs_get_wifi(std::string& ssid, std::string& pass) {
    nvs_handle_t nvs;
    if (nvs_open("wifi", NVS_READONLY, &nvs) != ESP_OK) return false;
    size_t ssid_len = 0;
    size_t pass_len = 0;
    if (nvs_get_str(nvs, "ssid", nullptr, &ssid_len) != ESP_OK || ssid_len == 0) {
        nvs_close(nvs);
        return false;
    }
    if (nvs_get_str(nvs, "pass", nullptr, &pass_len) != ESP_OK) pass_len = 0;
    ssid.resize(ssid_len);
    pass.resize(pass_len);
    nvs_get_str(nvs, "ssid", ssid.data(), &ssid_len);
    if (pass_len > 0) nvs_get_str(nvs, "pass", pass.data(), &pass_len);
    nvs_close(nvs);
    // Remove trailing nulls
    if (!ssid.empty() && ssid.back() == '\0') ssid.pop_back();
    if (!pass.empty() && pass.back() == '\0') pass.pop_back();
    return true;
}

static void nvs_set_wifi(const std::string& ssid, const std::string& pass) {
    nvs_handle_t nvs;
    if (nvs_open("wifi", NVS_READWRITE, &nvs) != ESP_OK) return;
    nvs_set_str(nvs, "ssid", ssid.c_str());
    nvs_set_str(nvs, "pass", pass.c_str());
    nvs_commit(nvs);
    nvs_close(nvs);
}

static esp_err_t handle_root(httpd_req_t* req) {
    const char* resp =
        "<!doctype html><html><head><meta charset='utf-8'/>"
        "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
        "<title>EchoEar Wi-Fi Setup</title></head><body>"
        "<h2>EchoEar Wi-Fi Setup</h2>"
        "<form method='POST' action='/save'>"
        "SSID<br/><input name='ssid' style='width:100%'/><br/>"
        "Password<br/><input name='pass' type='password' style='width:100%'/><br/><br/>"
        "<button type='submit'>Save & Restart</button>"
        "</form></body></html>";
    httpd_resp_set_type(req, "text/html");
    return httpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t handle_captive(httpd_req_t* req) {
    httpd_resp_set_status(req, "302 Found");
    httpd_resp_set_hdr(req, "Location", "http://192.168.4.1/");
    return httpd_resp_send(req, nullptr, 0);
}

static esp_err_t handle_save(httpd_req_t* req) {
    char buf[256];
    int received = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (received <= 0) return httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Bad Request");
    buf[received] = '\0';

    std::string body(buf);
    std::string ssid;
    std::string pass;
    auto get_field = [&](const char* key) -> std::string {
        std::string k = std::string(key) + "=";
        size_t pos = body.find(k);
        if (pos == std::string::npos) return "";
        pos += k.size();
        size_t end = body.find("&", pos);
        std::string val = body.substr(pos, end == std::string::npos ? std::string::npos : end - pos);
        // URL decode (minimal)
        for (size_t i = 0; i + 2 < val.size(); ++i) {
            if (val[i] == '%' && isxdigit((int)val[i + 1]) && isxdigit((int)val[i + 2])) {
                char hex[3] = { val[i + 1], val[i + 2], 0 };
                val[i] = (char)strtol(hex, nullptr, 16);
                val.erase(i + 1, 2);
            }
        }
        for (size_t i = 0; i < val.size(); ++i) {
            if (val[i] == '+') val[i] = ' ';
        }
        return val;
    };
    ssid = get_field("ssid");
    pass = get_field("pass");
    if (ssid.empty()) return httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "SSID required");

    nvs_set_wifi(ssid, pass);
    httpd_resp_sendstr(req, "Saved. Rebooting...");
    vTaskDelay(pdMS_TO_TICKS(500));
    esp_restart();
    return ESP_OK;
}

static void start_http_server() {
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.server_port = 80;
    httpd_start(&http_server, &config);

    httpd_uri_t root = {
        .uri = "/",
        .method = HTTP_GET,
        .handler = handle_root,
        .user_ctx = nullptr
    };
    httpd_uri_t save = {
        .uri = "/save",
        .method = HTTP_POST,
        .handler = handle_save,
        .user_ctx = nullptr
    };
    httpd_register_uri_handler(http_server, &root);
    httpd_register_uri_handler(http_server, &save);
    // Common captive portal probe URLs
    httpd_uri_t gen204 = {
        .uri = "/generate_204",
        .method = HTTP_GET,
        .handler = handle_captive,
        .user_ctx = nullptr
    };
    httpd_uri_t hotspot = {
        .uri = "/hotspot-detect.html",
        .method = HTTP_GET,
        .handler = handle_captive,
        .user_ctx = nullptr
    };
    httpd_uri_t apple = {
        .uri = "/library/test/success.html",
        .method = HTTP_GET,
        .handler = handle_captive,
        .user_ctx = nullptr
    };
    httpd_register_uri_handler(http_server, &gen204);
    httpd_register_uri_handler(http_server, &hotspot);
    httpd_register_uri_handler(http_server, &apple);
}

static void start_ap_provisioning() {
    uint8_t mac[6] = {};
    esp_read_mac(mac, ESP_MAC_WIFI_STA);
    char ap_ssid[32];
    snprintf(ap_ssid, sizeof(ap_ssid), "%s-%02X%02X", CONFIG_ECHOEAR_AP_SSID_PREFIX, mac[4], mac[5]);
    const char* ap_pass = CONFIG_ECHOEAR_AP_PASSWORD;

    ESP_LOGW(TAG, "Starting AP provisioning: SSID=%s PASS=%s", ap_ssid, ap_pass);
    lvgl_ui_set_status("AP Provisioning");

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t ap_cfg = {};
    strncpy((char*)ap_cfg.ap.ssid, ap_ssid, sizeof(ap_cfg.ap.ssid));
    if (ap_pass && strlen(ap_pass) > 0) {
        strncpy((char*)ap_cfg.ap.password, ap_pass, sizeof(ap_cfg.ap.password));
    }
    ap_cfg.ap.ssid_len = strlen(ap_ssid);
    ap_cfg.ap.max_connection = 4;
    ap_cfg.ap.authmode = (ap_pass && strlen(ap_pass) > 0) ? WIFI_AUTH_WPA_WPA2_PSK : WIFI_AUTH_OPEN;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap_cfg));
    ESP_ERROR_CHECK(esp_wifi_start());

    start_http_server();
    // Start DNS captive portal (resolve all domains to AP IP)
    dns_server_start(0xC0A80401); // 192.168.4.1
    ESP_LOGW(TAG, "Connect phone to %s and open http://192.168.4.1/", ap_ssid);
}

static bool wifi_init_sta(const char* ssid, const char* pass) {
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t wifi_config = {};
    strncpy((char*)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));
    strncpy((char*)wifi_config.sta.password, pass ? pass : "", sizeof(wifi_config.sta.password));

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    EventBits_t bits = xEventGroupWaitBits(wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdTRUE, pdMS_TO_TICKS(10000));
    return (bits & WIFI_CONNECTED_BIT) != 0;
}

static void send_json(const char* type) {
    if (!ws.connected()) return;
    cJSON* root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "type", type);
    cJSON_AddStringToObject(root, "device_id", ECHOEAR_DEVICE_ID);
    char* json = cJSON_PrintUnformatted(root);
    ws.send_text(json);
    cJSON_free(json);
    cJSON_Delete(root);
}

static void send_audio_start() {
    if (!ws.connected()) return;
    cJSON* root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "type", "audio_start");
    cJSON_AddStringToObject(root, "device_id", ECHOEAR_DEVICE_ID);
    cJSON_AddStringToObject(root, "format", "pcm16");
    cJSON_AddNumberToObject(root, "rate", ECHOEAR_SAMPLE_RATE);
    cJSON_AddNumberToObject(root, "channels", ECHOEAR_CHANNELS);
    char* json = cJSON_PrintUnformatted(root);
    ws.send_text(json);
    cJSON_free(json);
    cJSON_Delete(root);
}

static void send_audio_end() {
    if (!ws.connected()) return;
    cJSON* root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "type", "audio_end");
    cJSON_AddStringToObject(root, "device_id", ECHOEAR_DEVICE_ID);
    char* json = cJSON_PrintUnformatted(root);
    ws.send_text(json);
    cJSON_free(json);
    cJSON_Delete(root);
}

static void ws_on_text(const std::string& text) {
    cJSON* root = cJSON_Parse(text.c_str());
    if (!root) return;
    cJSON* type = cJSON_GetObjectItem(root, "type");
    if (cJSON_IsString(type)) {
        if (strcmp(type->valuestring, "tts_start") == 0) {
            ESP_LOGI(TAG, "TTS start - resetting audio buffer");
            std::lock_guard<std::mutex> lock(audio_buffer_mutex);
            audio_buffer.clear();
            // Don't reserve here - already pre-allocated at startup
            audio_buffer_read_pos = 0;
            tts_active = true;
            tts_finished = false;
        } else if (strcmp(type->valuestring, "tts_end") == 0) {
            ESP_LOGI(TAG, "TTS end - buffer size: %d bytes", audio_buffer.size());
            std::lock_guard<std::mutex> lock(audio_buffer_mutex);
            tts_finished = true;
        }
    }
    cJSON_Delete(root);
}

static void ws_on_binary(const uint8_t* data, size_t len) {
    ESP_LOGI(TAG, "Received binary data: %zu bytes, tts_active=%d", len, tts_active);

    // Decode incoming Opus packet to PCM and add to buffer
    if (tts_active) {
        // Decode Opus packet (60ms @ 16kHz = 960 samples = 1920 bytes PCM16)
        static int16_t pcm_buffer[2048];  // Large enough for any frame

        ESP_LOGI(TAG, "Decoding Opus packet...");
        int samples = opus.decode(data, len, pcm_buffer, 2048);

        if (samples > 0) {
            size_t pcm_bytes = samples * sizeof(int16_t);
            ESP_LOGI(TAG, "Decoded %d samples (%zu bytes PCM)", samples, pcm_bytes);

            std::lock_guard<std::mutex> lock(audio_buffer_mutex);
            size_t old_size = audio_buffer.size();
            const uint8_t* pcm_data = reinterpret_cast<const uint8_t*>(pcm_buffer);
            audio_buffer.insert(audio_buffer.end(), pcm_data, pcm_data + pcm_bytes);
            ESP_LOGI(TAG, "Buffer: %zu -> %zu bytes (+%zu)", old_size, audio_buffer.size(), pcm_bytes);
        } else {
            ESP_LOGE(TAG, "Opus decode failed for %zu byte packet", len);
        }
    } else {
        ESP_LOGW(TAG, "Ignoring binary data (tts not active)");
    }
}

static void audio_playback_task(void* arg) {
    ESP_LOGI(TAG, "Audio playback task started");
    static uint8_t playback_chunk[1920];  // 60ms @ 16kHz mono PCM16

    while (true) {
        // Wait for TTS to start
        while (!tts_active) {
            vTaskDelay(pdMS_TO_TICKS(10));
        }

        // Wait for prebuffering (accumulate ~500ms before starting)
        ESP_LOGI(TAG, "Prebuffering audio (need %d bytes)...", PREBUFFER_SIZE);
        while (tts_active) {
            {
                std::lock_guard<std::mutex> lock(audio_buffer_mutex);
                size_t available = audio_buffer.size() - audio_buffer_read_pos;
                ESP_LOGD(TAG, "Prebuffer: available=%zu, tts_finished=%d", available, tts_finished);
                if (available >= PREBUFFER_SIZE || (tts_finished && available > 0)) {
                    ESP_LOGI(TAG, "Prebuffer ready: available=%zu bytes", available);
                    break;
                }
            }
            vTaskDelay(pdMS_TO_TICKS(10));
        }

        ESP_LOGI(TAG, "Starting audio playback...");

        // Play buffered audio
        while (tts_active) {
            size_t chunk_size = 0;
            {
                std::lock_guard<std::mutex> lock(audio_buffer_mutex);
                size_t available = audio_buffer.size() - audio_buffer_read_pos;

                if (available == 0 && tts_finished) {
                    // Finished playing all audio
                    ESP_LOGI(TAG, "Audio playback complete");
                    tts_active = false;
                    audio_buffer.clear();
                    audio_buffer_read_pos = 0;
                    break;
                }

                if (available > 0) {
                    chunk_size = (available > sizeof(playback_chunk)) ? sizeof(playback_chunk) : available;
                    memcpy(playback_chunk, audio_buffer.data() + audio_buffer_read_pos, chunk_size);
                    audio_buffer_read_pos += chunk_size;
                }
            }

            if (chunk_size > 0) {
                ESP_LOGD(TAG, "Playing %zu bytes PCM", chunk_size);
                int ret = audio.play_frame(playback_chunk, chunk_size);
                if (ret < 0) {
                    ESP_LOGE(TAG, "Audio playback failed!");
                }
            } else {
                // Wait for more data
                vTaskDelay(pdMS_TO_TICKS(10));
            }
        }
    }
}

static void play_test_tone() {
    static int16_t tone[ECHOEAR_FRAME_SAMPLES];
    for (int i = 0; i < ECHOEAR_FRAME_SAMPLES; ++i) {
        float t = (float)i / (float)ECHOEAR_SAMPLE_RATE;
        float s = sinf(2.0f * 3.1415926f * 440.0f * t);
        tone[i] = (int16_t)(s * 8000.0f);
    }
    for (int i = 0; i < 10; ++i) {
        audio.play_frame((const uint8_t*)tone, sizeof(tone));
        vTaskDelay(pdMS_TO_TICKS(20));
    }
}

extern "C" void app_main(void) {
    if (ECHOEAR_LCD_ONLY_TEST) {
        lcd_only_test();
        return;
    }
    ESP_ERROR_CHECK(nvs_flash_init());

    // Initialize hardware LED for WebSocket status indication
    gpio_config_t led_cfg = {};
    led_cfg.pin_bit_mask = (1ULL << ECHOEAR_LED_G);
    led_cfg.mode = GPIO_MODE_OUTPUT;
    led_cfg.pull_down_en = GPIO_PULLDOWN_DISABLE;
    led_cfg.pull_up_en = GPIO_PULLUP_DISABLE;
    led_cfg.intr_type = GPIO_INTR_DISABLE;
    gpio_config(&led_cfg);
    gpio_set_level(ECHOEAR_LED_G, 0);  // LED off initially

    lvgl_ui_init();
    lvgl_ui_set_state(UI_STATE_BOOT);
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    wifi_event_group = xEventGroupCreate();
    esp_netif_create_default_wifi_sta();
    esp_netif_create_default_wifi_ap();
    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, nullptr));
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, nullptr));

    if (!audio.init()) {
        ESP_LOGE(TAG, "Audio init failed");
    } else {
        ESP_LOGI(TAG, "Playing test tone");
        play_test_tone();
        lvgl_ui_init_touch(audio.i2c_bus());

        // Initialize Opus decoder
        ESP_LOGI(TAG, "Initializing Opus decoder (%d Hz, %d ch)...", ECHOEAR_SAMPLE_RATE, ECHOEAR_CHANNELS);
        if (!opus.init(ECHOEAR_SAMPLE_RATE, ECHOEAR_CHANNELS)) {
            ESP_LOGE(TAG, "Opus decoder init FAILED!");
        } else {
            ESP_LOGI(TAG, "Opus decoder initialized successfully (frame_size=%zu samples)", opus.frame_size());
        }

        // Pre-allocate audio buffer to avoid fragmentation issues later
        ESP_LOGI(TAG, "Pre-allocating audio buffer (%d bytes)...", PREBUFFER_SIZE * 4);
        audio_buffer.reserve(PREBUFFER_SIZE * 4);  // Reserve ~2 seconds worth of audio
        ESP_LOGI(TAG, "Audio buffer capacity: %zu bytes", audio_buffer.capacity());

        // Start audio playback task for buffered TTS
        xTaskCreatePinnedToCore(audio_playback_task, "audio_play", 4096, nullptr, 5, nullptr, 0);
        ESP_LOGI(TAG, "Audio playback task created");
    }

    std::string ssid;
    std::string pass;
    bool have_saved = nvs_get_wifi(ssid, pass);
    bool connected = false;

    if (have_saved) {
        ESP_LOGI(TAG, "Connecting to saved Wi-Fi: %s", ssid.c_str());
        lvgl_ui_set_state(UI_STATE_WIFI_CONNECTING);
        connected = wifi_init_sta(ssid.c_str(), pass.c_str());
        if (!connected) {
            ESP_LOGW(TAG, "Wi-Fi connect failed, entering provisioning mode");
        }
    } else {
        ESP_LOGW(TAG, "No saved Wi-Fi, entering provisioning mode");
    }

    if (!connected) {
        lvgl_ui_set_state(UI_STATE_PROVISIONING);
        start_ap_provisioning();
        return;
    }
    lvgl_ui_set_state(UI_STATE_WIFI_CONNECTED);

    if (ECHOEAR_ENABLE_WAKE_WORD) {
        if (!wake.init()) {
            ESP_LOGE(TAG, "Wake word init failed (continuing without wake)");
            wake_ready = false;
        } else {
            wake_ready = true;
        }
    } else {
        ESP_LOGW(TAG, "Wake word disabled by config");
        wake_ready = false;
    }

    ws.on_text(ws_on_text);
    ws.on_binary(ws_on_binary);
    ws.on_connected([]() {
        ESP_LOGI(TAG, "WS on_connected callback triggered");
        // Set event bit to notify main loop (thread-safe)
        xEventGroupSetBits(wifi_event_group, WS_CONNECTED_BIT);
        // Turn on LED to indicate WebSocket connected
        gpio_set_level(ECHOEAR_LED_G, 1);
        send_json("hello");
    });
    ws.on_disconnected([]() {
        ESP_LOGI(TAG, "WS on_disconnected callback triggered");
        // Clear WS connected bit
        xEventGroupClearBits(wifi_event_group, WS_CONNECTED_BIT);
        // Turn off LED to indicate WebSocket disconnected
        gpio_set_level(ECHOEAR_LED_G, 0);
        if (xEventGroupGetBits(wifi_event_group) & STREAMING_ACTIVE_BIT) {
            xEventGroupClearBits(wifi_event_group, STREAMING_ACTIVE_BIT);
        }
    });

    lvgl_ui_set_debug_info("Debug: Connecting WS...");
    ESP_LOGI(TAG, "Attempting WS connection to: %s", ECHOEAR_WS_URL);
    ESP_LOGI(TAG, "Device ID: %s, Token: %s", ECHOEAR_DEVICE_ID, ECHOEAR_DEVICE_TOKEN);

    if (!ws.start(ECHOEAR_WS_URL, ECHOEAR_DEVICE_ID, ECHOEAR_DEVICE_TOKEN)) {
        ESP_LOGE(TAG, "WS connect failed");
        lvgl_ui_set_debug_info("Debug: WS failed!");
        lvgl_ui_set_state(UI_STATE_ERROR);
        return;
    }
    // Don't update UI here - ws.start() is async
    // UI will be updated by main loop when WS_CONNECTED_BIT is set
    lvgl_ui_set_debug_info("Debug: WS connecting...");

    lvgl_ui_set_touch_cb([](bool pressed) {
        if (pressed) {
            lvgl_ui_set_debug_info("Debug: Touch pressed");
            if (!ws.connected()) {
                lvgl_ui_set_state(UI_STATE_WIFI_CONNECTED);
                lvgl_ui_set_debug_info("Debug: Touch - WS not connected");
                return;
            }
            if (!(xEventGroupGetBits(wifi_event_group) & STREAMING_ACTIVE_BIT)) {
                xEventGroupSetBits(wifi_event_group, STREAMING_ACTIVE_BIT);
                lvgl_ui_set_state(UI_STATE_LISTENING);
                send_json("wake");
                send_audio_start();
            }
        } else {
            lvgl_ui_set_debug_info("Debug: Touch released");
            if (xEventGroupGetBits(wifi_event_group) & STREAMING_ACTIVE_BIT) {
                send_audio_end();
                xEventGroupClearBits(wifi_event_group, STREAMING_ACTIVE_BIT);
                lvgl_ui_set_debug_info("Debug: Audio stopped");
            }
            // Always restore WS_CONNECTED state if WebSocket is still connected
            if (xEventGroupGetBits(wifi_event_group) & WS_CONNECTED_BIT) {
                lvgl_ui_set_state(UI_STATE_WS_CONNECTED);
            }
        }
    });

    if (wake_ready) {
        wake.on_detected([](const std::string& word) {
            ESP_LOGI(TAG, "Wake word: %s", word.c_str());
            if (!(xEventGroupGetBits(wifi_event_group) & STREAMING_ACTIVE_BIT)) {
                xEventGroupSetBits(wifi_event_group, STREAMING_ACTIVE_BIT);
                lvgl_ui_set_state(UI_STATE_LISTENING);
                send_json("wake");
                send_audio_start();
            }
        });
    }

    // Main loop: feed wake word and stream audio after wake
    uint8_t frame[ECHOEAR_FRAME_BYTES];
    static bool ws_ui_updated = false;

    while (true) {
        // Check WS connection status and update UI (thread-safe from main loop)
        EventBits_t bits = xEventGroupGetBits(wifi_event_group);
        if ((bits & WS_CONNECTED_BIT) && !ws_ui_updated) {
            lvgl_ui_set_state(UI_STATE_WS_CONNECTED);
            lvgl_ui_set_debug_info("Debug: WS connected");
            ws_ui_updated = true;
            ESP_LOGI(TAG, "UI updated: WS connected");
        } else if (!(bits & WS_CONNECTED_BIT) && ws_ui_updated) {
            lvgl_ui_set_state(UI_STATE_WIFI_CONNECTED);
            lvgl_ui_set_debug_info("Debug: WS disconnected");
            ws_ui_updated = false;
            ESP_LOGI(TAG, "UI updated: WS disconnected");
        }

        int n = audio.read_frame(frame, sizeof(frame));
        if (n > 0 && wake_ready) {
            wake.feed((const int16_t*)frame, ECHOEAR_FRAME_SAMPLES);
        }

        if (bits & STREAMING_ACTIVE_BIT) {
            if (!ws.connected()) {
                xEventGroupClearBits(wifi_event_group, STREAMING_ACTIVE_BIT);
                lvgl_ui_set_state(UI_STATE_WS_CONNECTED);
                continue;
            }
            if (!ws.send_binary(frame, sizeof(frame))) {
                xEventGroupClearBits(wifi_event_group, STREAMING_ACTIVE_BIT);
                lvgl_ui_set_state(UI_STATE_WIFI_CONNECTED);
            }
        }
    }
}
